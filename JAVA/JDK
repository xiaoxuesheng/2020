JDK 8特性
1.日期类
2.lamda表达式
3.stream
4.使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。
从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。
CompletableFuture可以指定异步处理流程：
thenAccept()处理正常结果；
exceptional()处理异常结果；
thenApplyAsync()用于串行化另一个CompletableFuture；
anyOf()和allOf()用于并行化多个CompletableFuture。
原理：线程池里有Daemon线程

逃逸分析
Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在堆上分配内存
1、全局逃逸（GlobalEscape）
即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：
对象是一个静态变量
对象是一个已经发生逃逸的对象
对象作为当前方法的返回值

2、参数逃逸（ArgEscape）
即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。

3、没有逃逸
即方法中的对象没有发生逃逸。

逃逸分析优化
针对上面第三点，没有逃逸时，可以得到以下几个虚拟机的优化。
1) 锁消除
当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。
2) 标量替换
首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。
如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。
标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。
3) 栈上分配
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。

总结：
逃逸分析是为了优化 JVM 内存和提升程序性能的。开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好
例如：
return sb;可以改为：return sb.toString();
把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。

String长度限制
由byte[]的数组长度决定
编译期限制：以字面量的形式体现，需要在编译期以常量形式进入Class常量池，Class文件中常量池的格式规定长度不能超过65535，即2个字节的无符号数长度,2^16-1
运行期：长度不能超过int的范围，Integer#MAX_VALUE


